// Package {{ .PackageName }} is auto-generated by metricsgen. DO NOT EDIT.
package {{ .PackageName }}


import (
  {{- range $_, $dependency := .ImportDefs}}
  {{- if ne $dependency.Alias "" }}
  {{ $dependency.Alias }} "{{ $dependency.Dependency }}"
  {{- else }}
  "{{ $dependency.Dependency }}"
  {{- end }}
  {{- end }}
)

// toString is a helper to convert arbitrary values to string
func toString(values ...any) []string {
    if len(values) == 0 {
        return []string{}
    }
    ret := make([]string, len(values))
    for i, v := range values {
        st, ok :=  v.(string)
        if ok {
            ret[i] = st
            continue
        }
        it, ok := v.(int)
        if ok {
            ret[i] = fmt.Sprintf("%d", it) 
            continue
        }
        it64, ok := v.(int64)
        if ok {
          ret[i] = fmt.Sprintf("%d", it64)
        }
        bt, ok := v.(bool)
        if ok {
            ret[i] = fmt.Sprintf("%t", bt)
            continue
        }
        ft, ok := v.(float64)
        if ok {
            ret[i] = fmt.Sprintf("%g", ft)
            continue
        }

        sSlice, ok := v.([]string)
        if ok {
          sb := strings.Builder{}
          sb.WriteString("[")
          for i, val := range sSlice {
            if i != 0 {
              sb.WriteString(",")
            }
            sb.WriteString("\"")
            sb.WriteString(val)
            sb.WriteString("\"")
          }
          sb.WriteString("]")
          ret[i] = sb.String()
          continue
        }

        iSlice, ok := v.([]int)
        if ok {
          sb := strings.Builder{}
          sb.WriteString("[")
          for i, val := range iSlice {
            if i != 0 {
              sb.WriteString(",")
            }
            sb.WriteString(fmt.Sprintf("%d", val))
          }
          sb.WriteString("]")
          ret[i] = sb.String()
          continue
        }


        i64Slice, ok := v.([]int64)
        if ok {
          sb := strings.Builder{}
          sb.WriteString("[")
          for i, val := range i64Slice {
            if i != 0 {
              sb.WriteString(",")
            }
            sb.WriteString(fmt.Sprintf("%d", val))
          }
          sb.WriteString("]")

          ret[i] = sb.String()
          continue
        }

        fSlice, ok := v.([]float64)
        if ok {
          sb := strings.Builder{}
          sb.WriteString("[")
          for i, val := range fSlice {
            if i != 0 {
              sb.WriteString(",")
            }
            sb.WriteString(fmt.Sprintf("%g", val))
          }
          sb.WriteString("]") 
          ret[i] = sb.String()
          continue
        }

        bSlice, ok := v.([]bool)
        if ok {
          sb := strings.Builder{}
          sb.WriteString("[")
          for i, val := range bSlice {
            if i != 0 {
              sb.WriteString(" ")
            }
            sb.WriteString(fmt.Sprintf("%t", val))
          }
          sb.WriteString("]")
          ret[i] = sb.String()
          continue
        }

    }
    return ret
}

{{- range $enum := .EnumTypes }}
{{ if not (eq $enum.Description "")}}// {{$enum.EnumType}} {{ $enum.Description }}{{- end }}
type {{ $enum.EnumType }} {{ $enum.ValueType }}

func (e {{ $enum.EnumType }}) Val() {{ $enum.ValueType }} {
  return {{ $enum.ValueType }}(e)
}

const (
  {{- range $valueDef := .Values }}
  {{$enum.EnumType}}{{ $valueDef.ValueCase }} {{$enum.EnumType}}  = {{ $valueDef.Value }}
  {{- end }}
)
{{- end }}

type PrometheusMetrics struct {
  {{- range $metricStructName, $_ := .Metrics }}
  *Metric{{ $metricStructName }}
  {{- end }}
}

// NewPrometheusMetrics initializes the set of following metrics
{{- range $metricStructName, $def := .Metrics }}
//- {{$metricStructName}} {{ if ne $def.Description ""}} : {{$def.Description}} {{end}}
{{- end }}
func NewPrometheusMetrics(reg *promsdk.Registry) (PrometheusMetrics, error) {
  m := PrometheusMetrics{
  {{- range $metricStructName, $_ := .Metrics }}
    Metric{{$metricStructName}} : &Metric{{ $metricStructName }}{},
  {{- end }}
  }
  {{- range $metricStructName, $_ := .Metrics}}
  if err := m.Metric{{$metricStructName}}.init(reg); err != nil {
    return m, err
  }
  {{- end}}
  return m, nil
}

{{ range $metricStructName, $def := .Metrics }}
// Metric{{ $metricStructName }} {{ $def.Description }}
type Metric{{ $metricStructName }} struct{
    Data  *promsdk.{{$def.MetricType }}Vec
}

func (m *Metric{{ $metricStructName }}) init(reg *promsdk.Registry) error {
    data := promsdk.New{{$def.MetricType}}Vec(
        promsdk.{{$def.MetricType}}Opts{
            Name : "{{ $def.Name }}",
            Help : "{{ $def.Description }}",
            {{ if ne (len $def.Buckets) 0 }}Buckets: []float64{
              {{range $def.Buckets}} {{ . }}, {{end}}
            },{{end}}
        },
        []string{ 
            {{ if gt (len $def.RequiredAttributes) 0 }}// Required attributes {{ end }}
            {{ range $def.RequiredAttributes }} "{{ .Name }}", {{ end}}
            {{ if gt (len $def.OptionalAttributes) 0 }}// Optional attributes {{ end }}
            {{  range $def.OptionalAttributes }} "{{ .Name }}", {{end}}
        },
    )
    if err := reg.Register(data); err != nil {
        return err
    }
    m.Data = data
    return nil
}

{{ $metricFuncName := "Add"}}
{{ if eq $def.MetricType "Histogram" }}
    {{ $metricFuncName = "Observe" }}
{{ end }}
func (m *Metric{{ $metricStructName }}){{$metricFuncName}}(
  value {{ $def.Value}},
  {{- range $def.RequiredAttributes }}
  {{ .Field }} {{ .ValueType }},
  {{- end}} 
  attributeOpts ...Attribute{{$metricStructName}}Option,
) {
    options := &Attribute{{$metricStructName}}Options{}
    options.Apply(attributeOpts...)
    m.Data.WithLabelValues(
      append(toString(
        {{ range $def.RequiredAttributes }} {{if .Enum}} {{.Field}}.Val() {{else}} {{ .Field }} {{end}}, {{ end }}
      ), options.Labels()...)...,
    ).{{$metricFuncName}}(float64(value))
}

type Attribute{{$metricStructName}}Options struct {
  {{- range $def.OptionalAttributes }}
  {{ .Field }} *{{ .ValueType }}
  {{- end }}
}

type Attribute{{$metricStructName}}Option func(*Attribute{{$metricStructName}}Options)

func (o *Attribute{{$metricStructName}}Options) Apply(opts ...Attribute{{$metricStructName}}Option) {
  for _, opt := range opts {
    opt(o)
  }
}

func (o *Attribute{{$metricStructName}}Options) Labels() []string {
  ret := []any{}
  {{- range $def.OptionalAttributes }}
  if o.{{ .Field }} != nil {
    {{- if .Enum }}
    ret = append(ret, (*o.{{.Field}}).Val())))
    {{- else }}
    ret = append(ret, *o.{{.Field}})
    {{- end }}
  }
  {{- end }}
  return toString(ret...)
}

{{ range $def.OptionalAttributes}}
{{- if ne $def.Description ""}}
// With{{$metricStructName}}{{.CamelCase}} sets the optional {{ .Name }} attribute
// corresponding to {{.Description}}
{{- end }}
func With{{$metricStructName}}{{.CamelCase}}({{.Field}} {{ .ValueType }}) Attribute{{$metricStructName}}Option {
  return func(o *Attribute{{$metricStructName}}Options) {
    val := &{{.Field}}
    o.{{.Field}} = val
  }
}

{{- end }}
{{ end }}