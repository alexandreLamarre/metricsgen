package metricsgen

import (
	"fmt"
	"os"
	"strings"
)

type Config struct {
	Attributes    map[string]Attribute `yaml:"attributes"`
	Metrics       map[string]Metric    `yaml:"metrics"`
	ExportFormats []string             `yaml:"export_formats"`
}

func AttributesForMetric(m Metric, attrTable map[string]Attribute) []Attribute {
	ret := []Attribute{}
	for _, attr := range m.Attributes {
		ret = append(ret, attrTable[attr])
	}
	return ret
}

type Attribute struct {
	Name         string `yaml:"name"`
	Description  string `yaml:"description"`
	Type         string `yaml:"type"`
	DefaultValue string `yaml:"default_value"`
	Required     bool   `yaml:"required"`
}

func (a Attribute) Markdown() string {
	var requiredStr string
	if a.Required {
		requiredStr = " ✅ "
	} else {
		requiredStr = " ❌ "
	}
	return fmt.Sprintf("| %s | %s | %s | %s |  %s |", a.Name, a.Description, a.Type, requiredStr, a.DefaultValue)
}

type Metric struct {
	Name               string `yaml:"name"`
	Short              string `yaml:"short"`
	Long               string `yaml:"long"`
	Unit               string `yaml:"unit"`
	ValueType          string `yaml:"metric_type"`
	*MetricTypeSum     `yaml:"sum,omitempty"`
	*MetricTypeGauge   `yaml:"gauge,omitempty"`
	*MetricTypeHist    `yaml:"histogram,omitempty"`
	*MetricTypeExpHist `yaml:"exponential_histogram,omitempty"`
	Attributes         []string `yaml:"attributes"`
}

func (m Metric) Markdown(attrs map[string]Attribute) string {
	sb := strings.Builder{}
	header := fmt.Sprintf("## %s\n\n", m.Name)
	sb.WriteString(header)
	description := fmt.Sprintf(
		"%s\n\n", m.Short,
	)
	sb.WriteString(description)
	if m.Long != "" {
		description := fmt.Sprintf("%s\n\n", m.Long)
		sb.WriteString(description)
	}
	metricTableHeader := "| Unit | Metric Type | ValueType |\n| ---- | ------------ | --------- |\n"
	sb.WriteString(metricTableHeader)
	metricTable := fmt.Sprintf("| %s | %s | %s |\n", m.Unit, m.MetricTypeString(), m.ValueType)
	sb.WriteString(metricTable)
	if len(m.Attributes) > 0 {
		sb.WriteString("\n\n")
		sb.WriteString(attributeTableMd())
		for _, attr := range m.Attributes {
			if attribute, ok := attrs[attr]; ok {
				sb.WriteString(attribute.Markdown())
			}
		}
	}

	return sb.String()
}

func (m Metric) MetricTypeString() string {
	if m.MetricTypeSum != nil {
		return "Sum"
	}
	if m.MetricTypeGauge != nil {
		return "Gauge"
	}
	if m.MetricTypeHist != nil {
		return "Histogram"
	}
	if m.MetricTypeExpHist != nil {
		return "Exponential Histogram"
	}
	panic("unknown metric type")
}

type MetricTypeSum struct {
	ValueType   string `yaml:"value_type"`
	Aggregation string `yaml:"aggregation"`
}

type MetricTypeGauge struct {
	ValueType   string `yaml:"value_type"`
	Aggregation string `yaml:"aggregation"`
}

type MetricTypeHist struct {
	ValueType   string `yaml:"value_type"`
	Aggregation string `yaml:"aggregation"`
}

type MetricTypeExpHist struct {
}

func (c *Config) Validate() error {
	if c == nil {
		return fmt.Errorf("config is nil")
	}
	if len(c.Attributes) == 0 && len(c.Metrics) == 0 {
		return fmt.Errorf("config must have at least one attribute or metric")
	}
	return nil
}

func (cfg *Config) Gen() error {
	if err := cfg.Validate(); err != nil {
		return err
	}

	if err := cfg.GenerateCode(); err != nil {
		return err
	}

	if err := cfg.generateDocs(); err != nil {
		return err
	}
	return nil
}

func (cfg *Config) GenerateCode() error {
	// get current package name

	header := fmt.Sprintf("// Package %s is auto-generated by metricsgen. DO NOT EDIT.\n", "metricsgen")
	packageLine := fmt.Sprintf("package %s\n", "main")

	if err := os.WriteFile("metricsgen.go", []byte(header+packageLine), 0644); err != nil {
		return err
	}
	return nil
}

func (cfg *Config) metricStructName(m Metric) string {
	return "Metric" + OtelStringToCamelCase(m.Name)
}

func (cfg *Config) GenerateMetricInfo() string {
	attrDef := []attributeDef{}

	for _, m := range cfg.Metrics {
		attrDef = append(
			attrDef,
			attributeDef{
				pointer:  true,
				attrType: cfg.metricStructName(m),
			},
		)
	}

	s := NewStructWriter(
		"MetricInfo",
		"",
		attrDef,
	)

	return s.Generate()
}

func (cfg *Config) generateMetricAttributesStruct(m Metric) string {
	attrs := AttributesForMetric(m, cfg.Attributes)
	attrDef := []attributeDef{}

	for _, attr := range attrs {
		attrDef = append(attrDef, attributeDef{
			field:    OtelStringToCamelCase(attr.Name),
			attrType: "string",
			pointer:  false,
		})
	}
	s := NewStructWriter(
		cfg.metricStructName(m)+"Attributes",
		"",
		attrDef,
	)

	return s.Generate()
}

func (cfg *Config) GenerateAllMetricAttributesStruct() string {
	got := ""
	for _, m := range cfg.Metrics {
		ret := cfg.generateMetricAttributesStruct(m)
		got += ret
	}
	return got
}

func (cfg *Config) generateMetricStruct(m Metric) string {
	s := NewStructWriter(
		cfg.metricStructName(m),
		m.Short,
		[]attributeDef{},
	)

	return s.Generate()
}

func (cfg *Config) GenerateAllMetricsStruct() string {
	got := ""
	for _, m := range cfg.Metrics {
		got += cfg.generateMetricStruct(m)
	}
	return got
}

func attributeTableMd() string {
	return "### Attributes\n\n" + "| Name | Description | Type | Required | Default Value |\n" +
		"|------|-------------|------| ------- | ---------------|\n"
}

func (cfg *Config) generateDocs() error {
	sb := strings.Builder{}
	header := "# Metrics\n\n"

	sb.WriteString(header)
	sb.WriteString(cfg.generateTOC())
	sb.WriteString("\n\n")
	for _, metric := range cfg.Metrics {
		sb.WriteString(metric.Markdown(cfg.Attributes))
		sb.WriteString("\n\n")
	}
	return os.WriteFile("metrics.md", []byte(sb.String()), 0644)
}

func (cfg *Config) generateTOC() string {
	sb := strings.Builder{}
	for _, metric := range cfg.Metrics {
		sb.WriteString(
			fmt.Sprintf(
				"- [%s](#%s) : %s\n",
				metric.Name, strings.ToLower(
					strings.ReplaceAll(
						strings.ReplaceAll(metric.Name, ".", ""),
						" ", "-"),
				),
				metric.Short,
			),
		)
	}
	return sb.String()
}
