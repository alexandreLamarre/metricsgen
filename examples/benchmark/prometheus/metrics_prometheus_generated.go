// Package benchmark is auto-generated by metricsgen. DO NOT EDIT.
package benchmark

import (
	"fmt"
	promsdk "github.com/prometheus/client_golang/prometheus"
	"strings"
)

// toString is a helper to convert arbitrary values to string
func toString(values ...any) []string {
	if len(values) == 0 {
		return []string{}
	}
	ret := make([]string, len(values))
	for i, v := range values {
		st, ok := v.(string)
		if ok {
			ret[i] = st
			continue
		}
		it, ok := v.(int)
		if ok {
			ret[i] = fmt.Sprintf("%d", it)
			continue
		}
		it64, ok := v.(int64)
		if ok {
			ret[i] = fmt.Sprintf("%d", it64)
		}
		bt, ok := v.(bool)
		if ok {
			ret[i] = fmt.Sprintf("%t", bt)
			continue
		}
		ft, ok := v.(float64)
		if ok {
			ret[i] = fmt.Sprintf("%f", ft)
			continue
		}

		sSlice, ok := v.([]string)
		if ok {
			ret[i] = strings.Join(sSlice, ";")
			continue
		}

		iSlice, ok := v.([]int64)
		if ok {
			sb := strings.Builder{}
			for i, val := range iSlice {
				if i != 0 {
					sb.WriteString(";")
				}
				sb.WriteString(fmt.Sprintf("%d", val))
			}
			ret[i] = sb.String()
			continue
		}

		i64Slice, ok := v.([]int64)
		if ok {
			sb := strings.Builder{}
			for i, val := range i64Slice {
				if i != 0 {
					sb.WriteString(";")
				}
				sb.WriteString(fmt.Sprintf("%d", val))
			}
			ret[i] = sb.String()
			continue
		}

		fSlice, ok := v.([]float64)
		if ok {
			sb := strings.Builder{}
			for i, val := range fSlice {
				if i != 0 {
					sb.WriteString(";")
				}
				sb.WriteString(fmt.Sprintf("%f", val))
			}
			ret[i] = sb.String()
			continue
		}

		bSlice, ok := v.([]bool)
		if ok {
			sb := strings.Builder{}
			for i, val := range bSlice {
				if i != 0 {
					sb.WriteString(";")
				}
				sb.WriteString(fmt.Sprintf("%t", val))
			}
			ret[i] = sb.String()
			continue
		}

	}
	return ret
}

type PrometheusMetrics struct {
	*MetricEightLabelCounter
	*MetricFourLabelCounter
	*MetricNoLabelCounter
	*MetricOneLabelCounter
	*MetricSplitLabelCounter
}

// NewPrometheusMetrics initializes the set of following metrics
// - EightLabelCounter  : counter with 8 labels
// - FourLabelCounter  : counter with 4 labels
// - NoLabelCounter  : counter with no labels
// - OneLabelCounter  : counter with 1 label
// - SplitLabelCounter  : counter with 4 labels and 4 optional labels
func NewPrometheusMetrics(reg *promsdk.Registry) (PrometheusMetrics, error) {
	m := PrometheusMetrics{
		MetricEightLabelCounter: &MetricEightLabelCounter{},
		MetricFourLabelCounter:  &MetricFourLabelCounter{},
		MetricNoLabelCounter:    &MetricNoLabelCounter{},
		MetricOneLabelCounter:   &MetricOneLabelCounter{},
		MetricSplitLabelCounter: &MetricSplitLabelCounter{},
	}
	if err := m.MetricEightLabelCounter.init(reg); err != nil {
		return m, err
	}
	if err := m.MetricFourLabelCounter.init(reg); err != nil {
		return m, err
	}
	if err := m.MetricNoLabelCounter.init(reg); err != nil {
		return m, err
	}
	if err := m.MetricOneLabelCounter.init(reg); err != nil {
		return m, err
	}
	if err := m.MetricSplitLabelCounter.init(reg); err != nil {
		return m, err
	}
	return m, nil
}

// MetricEightLabelCounter counter with 8 labels
type MetricEightLabelCounter struct {
	Data *promsdk.CounterVec
}

func (m *MetricEightLabelCounter) init(reg *promsdk.Registry) error {
	data := promsdk.NewCounterVec(
		promsdk.CounterOpts{
			Name: "eight_label_counter_total",
			Help: "counter with 8 labels",
		},
		[]string{
			// Required attributes
			"stringLabel", "stringLabel2", "stringLabel3", "stringLabel4", "stringLabel5", "stringLabel6", "stringLabel7", "stringLabel8",
		},
	)
	if err := reg.Register(data); err != nil {
		return err
	}
	m.Data = data
	return nil
}

func (m *MetricEightLabelCounter) Add(
	value int64,
	stringLabel string,
	stringLabel2 string,
	stringLabel3 string,
	stringLabel4 string,
	stringLabel5 string,
	stringLabel6 string,
	stringLabel7 string,
	stringLabel8 string,
	attributeOpts ...AttributeEightLabelCounterOption,
) {
	options := &AttributeEightLabelCounterOptions{}
	options.Apply(attributeOpts...)
	m.Data.WithLabelValues(
		append(toString(
			stringLabel, stringLabel2, stringLabel3, stringLabel4, stringLabel5, stringLabel6, stringLabel7, stringLabel8,
		), options.Labels()...)...,
	).Add(float64(value))
}

type AttributeEightLabelCounterOptions struct {
}

type AttributeEightLabelCounterOption func(*AttributeEightLabelCounterOptions)

func (o *AttributeEightLabelCounterOptions) Apply(opts ...AttributeEightLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeEightLabelCounterOptions) Labels() []string {
	ret := []any{}
	return toString(ret...)
}

// MetricFourLabelCounter counter with 4 labels
type MetricFourLabelCounter struct {
	Data *promsdk.CounterVec
}

func (m *MetricFourLabelCounter) init(reg *promsdk.Registry) error {
	data := promsdk.NewCounterVec(
		promsdk.CounterOpts{
			Name: "four_label_counter_total",
			Help: "counter with 4 labels",
		},
		[]string{
			// Required attributes
			"stringLabel", "stringLabel2", "stringLabel3", "stringLabel4",
		},
	)
	if err := reg.Register(data); err != nil {
		return err
	}
	m.Data = data
	return nil
}

func (m *MetricFourLabelCounter) Add(
	value int64,
	stringLabel string,
	stringLabel2 string,
	stringLabel3 string,
	stringLabel4 string,
	attributeOpts ...AttributeFourLabelCounterOption,
) {
	options := &AttributeFourLabelCounterOptions{}
	options.Apply(attributeOpts...)
	m.Data.WithLabelValues(
		append(toString(
			stringLabel, stringLabel2, stringLabel3, stringLabel4,
		), options.Labels()...)...,
	).Add(float64(value))
}

type AttributeFourLabelCounterOptions struct {
}

type AttributeFourLabelCounterOption func(*AttributeFourLabelCounterOptions)

func (o *AttributeFourLabelCounterOptions) Apply(opts ...AttributeFourLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeFourLabelCounterOptions) Labels() []string {
	ret := []any{}
	return toString(ret...)
}

// MetricNoLabelCounter counter with no labels
type MetricNoLabelCounter struct {
	Data *promsdk.CounterVec
}

func (m *MetricNoLabelCounter) init(reg *promsdk.Registry) error {
	data := promsdk.NewCounterVec(
		promsdk.CounterOpts{
			Name: "no_label_counter_total",
			Help: "counter with no labels",
		},
		[]string{},
	)
	if err := reg.Register(data); err != nil {
		return err
	}
	m.Data = data
	return nil
}

func (m *MetricNoLabelCounter) Add(
	value int64,
	attributeOpts ...AttributeNoLabelCounterOption,
) {
	options := &AttributeNoLabelCounterOptions{}
	options.Apply(attributeOpts...)
	m.Data.WithLabelValues(
		append(toString(), options.Labels()...)...,
	).Add(float64(value))
}

type AttributeNoLabelCounterOptions struct {
}

type AttributeNoLabelCounterOption func(*AttributeNoLabelCounterOptions)

func (o *AttributeNoLabelCounterOptions) Apply(opts ...AttributeNoLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeNoLabelCounterOptions) Labels() []string {
	ret := []any{}
	return toString(ret...)
}

// MetricOneLabelCounter counter with 1 label
type MetricOneLabelCounter struct {
	Data *promsdk.CounterVec
}

func (m *MetricOneLabelCounter) init(reg *promsdk.Registry) error {
	data := promsdk.NewCounterVec(
		promsdk.CounterOpts{
			Name: "one_label_counter_total",
			Help: "counter with 1 label",
		},
		[]string{
			// Required attributes
			"stringLabel",
		},
	)
	if err := reg.Register(data); err != nil {
		return err
	}
	m.Data = data
	return nil
}

func (m *MetricOneLabelCounter) Add(
	value int64,
	stringLabel string,
	attributeOpts ...AttributeOneLabelCounterOption,
) {
	options := &AttributeOneLabelCounterOptions{}
	options.Apply(attributeOpts...)
	m.Data.WithLabelValues(
		append(toString(
			stringLabel,
		), options.Labels()...)...,
	).Add(float64(value))
}

type AttributeOneLabelCounterOptions struct {
}

type AttributeOneLabelCounterOption func(*AttributeOneLabelCounterOptions)

func (o *AttributeOneLabelCounterOptions) Apply(opts ...AttributeOneLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeOneLabelCounterOptions) Labels() []string {
	ret := []any{}
	return toString(ret...)
}

// MetricSplitLabelCounter counter with 4 labels and 4 optional labels
type MetricSplitLabelCounter struct {
	Data *promsdk.CounterVec
}

func (m *MetricSplitLabelCounter) init(reg *promsdk.Registry) error {
	data := promsdk.NewCounterVec(
		promsdk.CounterOpts{
			Name: "split_label_counter_total",
			Help: "counter with 4 labels and 4 optional labels",
		},
		[]string{
			// Required attributes
			"stringLabel", "stringLabel2", "stringLabel3", "stringLabel4",
			// Optional attributes
			"stringLabel5", "stringLabel6", "stringLabel7", "stringLabel8",
		},
	)
	if err := reg.Register(data); err != nil {
		return err
	}
	m.Data = data
	return nil
}

func (m *MetricSplitLabelCounter) Add(
	value int64,
	stringLabel string,
	stringLabel2 string,
	stringLabel3 string,
	stringLabel4 string,
	attributeOpts ...AttributeSplitLabelCounterOption,
) {
	options := &AttributeSplitLabelCounterOptions{}
	options.Apply(attributeOpts...)
	m.Data.WithLabelValues(
		append(toString(
			stringLabel, stringLabel2, stringLabel3, stringLabel4,
		), options.Labels()...)...,
	).Add(float64(value))
}

type AttributeSplitLabelCounterOptions struct {
	stringLabel5 *string
	stringLabel6 *string
	stringLabel7 *string
	stringLabel8 *string
}

type AttributeSplitLabelCounterOption func(*AttributeSplitLabelCounterOptions)

func (o *AttributeSplitLabelCounterOptions) Apply(opts ...AttributeSplitLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeSplitLabelCounterOptions) Labels() []string {
	ret := []any{}
	if o.stringLabel5 != nil {
		ret = append(ret, *o.stringLabel5)
	}
	if o.stringLabel6 != nil {
		ret = append(ret, *o.stringLabel6)
	}
	if o.stringLabel7 != nil {
		ret = append(ret, *o.stringLabel7)
	}
	if o.stringLabel8 != nil {
		ret = append(ret, *o.stringLabel8)
	}
	return toString(ret...)
}

// WithSplitLabelCounterStringLabel5 sets the optional stringLabel5 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel5(stringLabel5 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel5
		o.stringLabel5 = val
	}
}

// WithSplitLabelCounterStringLabel6 sets the optional stringLabel6 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel6(stringLabel6 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel6
		o.stringLabel6 = val
	}
}

// WithSplitLabelCounterStringLabel7 sets the optional stringLabel7 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel7(stringLabel7 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel7
		o.stringLabel7 = val
	}
}

// WithSplitLabelCounterStringLabel8 sets the optional stringLabel8 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel8(stringLabel8 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel8
		o.stringLabel8 = val
	}
}
