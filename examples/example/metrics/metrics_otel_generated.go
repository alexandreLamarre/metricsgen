// Package metrics is auto-generated by metricsgen. DO NOT EDIT.
package metrics

import (
	"context"
	prommodel "github.com/prometheus/common/model"
	otelattribute "go.opentelemetry.io/otel/attribute"
	otelmetricsdk "go.opentelemetry.io/otel/metric"
)

// FIXME:hack for conformance tests, consistent metric exposing with prometheus driver
func init() {
	prommodel.NameValidationScheme = prommodel.LegacyValidation
}

// EnumCpuMode cpu state
type EnumCpuMode string

func (e EnumCpuMode) Val() string {
	return string(e)
}

const (
	EnumCpuModeIdle   EnumCpuMode = "idle"
	EnumCpuModeActive EnumCpuMode = "active"
)

// EnumRandomInt random enum int
type EnumRandomInt int

func (e EnumRandomInt) Val() int {
	return int(e)
}

const (
	EnumRandomIntOn  EnumRandomInt = 0
	EnumRandomIntOff EnumRandomInt = 1
)

type Metrics struct {
	*MetricDummyTcpConnlat
	*MetricDummyTcpRx
	*MetricDummyTcpTx
}

// NewMetrics initializes the set of following metrics
// - DummyTcpConnlat  : TCP connection latency ms
// - DummyTcpRx  : TCP received bytes
// - DummyTcpTx  : TCP transmitted bytes
func NewMetrics(meter otelmetricsdk.Meter) (Metrics, error) {
	m := Metrics{
		MetricDummyTcpConnlat: &MetricDummyTcpConnlat{},
		MetricDummyTcpRx:      &MetricDummyTcpRx{},
		MetricDummyTcpTx:      &MetricDummyTcpTx{},
	}
	if err := m.MetricDummyTcpConnlat.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricDummyTcpRx.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricDummyTcpTx.init(meter); err != nil {
		return m, err
	}
	return m, nil
}

// MetricDummyTcpConnlat TCP connection latency ms
type MetricDummyTcpConnlat struct {
	data otelmetricsdk.Float64Histogram
}

func (m *MetricDummyTcpConnlat) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Float64Histogram(
		"dummy.tcp.connlat",
		otelmetricsdk.WithDescription("TCP connection latency ms"),
		otelmetricsdk.WithUnit("ms"),
	)
	return err
}

// Record records a data point for the specified metric
//
// • pid : Process ID
// • pidGid : Process Group ID
func (m *MetricDummyTcpConnlat) Record(
	ctx context.Context,
	value float64,
	pid int,
	pidGid int,
	attributeOpts ...AttributeDummyTcpConnlatOption,
) {
	options := &AttributeDummyTcpConnlatOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
		otelattribute.Int("pid.gid", pidGid),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Record(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeDummyTcpConnlatOptions struct {
	cpuId     *int
	randomInt *EnumRandomInt
}

type AttributeDummyTcpConnlatOption func(*AttributeDummyTcpConnlatOptions)

func (o *AttributeDummyTcpConnlatOptions) Apply(opts ...AttributeDummyTcpConnlatOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeDummyTcpConnlatOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	if o.cpuId != nil {
		ret = append(ret, otelattribute.Int("cpu.id", *o.cpuId))
	}
	if o.randomInt != nil {
		ret = append(ret, otelattribute.Int("random.int", (*o.randomInt).Val()))
	}
	return ret
}

// WithDummyTcpConnlatCpuId sets the optional cpu.id attribute
// corresponding to cpu id in the range [0, numCPU]
func WithDummyTcpConnlatCpuId(cpuId int) AttributeDummyTcpConnlatOption {
	return func(o *AttributeDummyTcpConnlatOptions) {
		val := &cpuId
		o.cpuId = val
	}
}

// WithDummyTcpConnlatRandomInt sets the optional random.int attribute
// corresponding to random enum int
func WithDummyTcpConnlatRandomInt(randomInt EnumRandomInt) AttributeDummyTcpConnlatOption {
	return func(o *AttributeDummyTcpConnlatOptions) {
		val := &randomInt
		o.randomInt = val
	}
}

// MetricDummyTcpRx TCP received bytes
type MetricDummyTcpRx struct {
	data otelmetricsdk.Int64Gauge
}

func (m *MetricDummyTcpRx) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Gauge(
		"dummy.tcp.rx",
		otelmetricsdk.WithDescription("TCP received bytes"),
		otelmetricsdk.WithUnit("By"),
	)
	return err
}

// Record records a data point for the specified metric
//
// • pid : Process ID
// • randomInt : random enum int
func (m *MetricDummyTcpRx) Record(
	ctx context.Context,
	value int64,
	pid int,
	randomInt EnumRandomInt,
	attributeOpts ...AttributeDummyTcpRxOption,
) {
	options := &AttributeDummyTcpRxOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
		otelattribute.Int("random.int", randomInt.Val()),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Record(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeDummyTcpRxOptions struct {
	cpuMode *EnumCpuMode
}

type AttributeDummyTcpRxOption func(*AttributeDummyTcpRxOptions)

func (o *AttributeDummyTcpRxOptions) Apply(opts ...AttributeDummyTcpRxOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeDummyTcpRxOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	if o.cpuMode != nil {
		ret = append(ret, otelattribute.String("cpu.mode", (*o.cpuMode).Val()))
	}
	return ret
}

// WithDummyTcpRxCpuMode sets the optional cpu.mode attribute
// corresponding to cpu state
func WithDummyTcpRxCpuMode(cpuMode EnumCpuMode) AttributeDummyTcpRxOption {
	return func(o *AttributeDummyTcpRxOptions) {
		val := &cpuMode
		o.cpuMode = val
	}
}

// MetricDummyTcpTx TCP transmitted bytes
type MetricDummyTcpTx struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricDummyTcpTx) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"dummy.tcp.tx",
		otelmetricsdk.WithDescription("TCP transmitted bytes"),
		otelmetricsdk.WithUnit("By"),
	)
	return err
}

// Record records a data point for the specified metric
//
// • pid : Process ID
// • pidGid : Process Group ID
// • cpuId : cpu id in the range [0, numCPU]
// • cpuMode : cpu state
func (m *MetricDummyTcpTx) Record(
	ctx context.Context,
	value int64,
	pid int,
	pidGid int,
	cpuId int,
	cpuMode EnumCpuMode,
	attributeOpts ...AttributeDummyTcpTxOption,
) {
	options := &AttributeDummyTcpTxOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
		otelattribute.Int("pid.gid", pidGid),
		otelattribute.Int("cpu.id", cpuId),
		otelattribute.String("cpu.mode", cpuMode.Val()),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeDummyTcpTxOptions struct {
}

type AttributeDummyTcpTxOption func(*AttributeDummyTcpTxOptions)

func (o *AttributeDummyTcpTxOptions) Apply(opts ...AttributeDummyTcpTxOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeDummyTcpTxOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}
