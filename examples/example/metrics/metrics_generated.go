// Package metrics is auto-generated by metricsgen. DO NOT EDIT.
package metrics

import (
	"context"
	otelattribute "go.opentelemetry.io/otel/attribute"
	otelmetricsdk "go.opentelemetry.io/otel/metric"
)

type Metrics struct {
	*MetricDummyTcpConnlat
	*MetricDummyTcpRx
	*MetricDummyTcpTx
}

// NewMetrics initializes the set of following metrics
// - DummyTcpConnlat  : TCP connection latency ms
// - DummyTcpRx  : TCP received bytes
// - DummyTcpTx  : TCP transmitted bytes
func NewMetrics(meter otelmetricsdk.Meter) (Metrics, error) {
	m := Metrics{
		MetricDummyTcpConnlat: &MetricDummyTcpConnlat{},
		MetricDummyTcpRx:      &MetricDummyTcpRx{},
		MetricDummyTcpTx:      &MetricDummyTcpTx{},
	}
	if err := m.MetricDummyTcpConnlat.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricDummyTcpRx.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricDummyTcpTx.init(meter); err != nil {
		return m, err
	}
	return m, nil
}

// MetricDummyTcpConnlat TCP connection latency ms
type MetricDummyTcpConnlat struct {
	data otelmetricsdk.Float64Histogram
}

func (m *MetricDummyTcpConnlat) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Float64Histogram(
		"dummy.tcp.connlat",
		otelmetricsdk.WithDescription("TCP connection latency ms"),
		otelmetricsdk.WithUnit("ms"),
	)
	return err
}

// Record records a data point for the specified metric
// - pid : Process ID
// - pidGid : Process Group ID
func (m *MetricDummyTcpConnlat) Record(
	ctx context.Context,
	value float64,
	pid int,
	pidGid int,
	attributeOpts ...AttributeDummyTcpConnlatOption,
) {
	options := &AttributeDummyTcpConnlatOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
		otelattribute.Int("pid.gid", pidGid),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Record(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeDummyTcpConnlatOptions struct {
	cpuId *int
}

type AttributeDummyTcpConnlatOption func(*AttributeDummyTcpConnlatOptions)

func (o *AttributeDummyTcpConnlatOptions) Apply(opts ...AttributeDummyTcpConnlatOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeDummyTcpConnlatOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	if o.cpuId != nil {
		ret = append(ret, otelattribute.Int("cpu.id", *o.cpuId))
	}
	return ret
}

// WithDummyTcpConnlatCpuId sets the optional cpu.id attribute
// corresponding to cpu id in the range [0, numCPU]
func WithDummyTcpConnlatCpuId(cpuId int) AttributeDummyTcpConnlatOption {
	return func(o *AttributeDummyTcpConnlatOptions) {
		val := &cpuId
		o.cpuId = val
	}
}

// MetricDummyTcpRx TCP received bytes
type MetricDummyTcpRx struct {
	data otelmetricsdk.Int64Gauge
}

func (m *MetricDummyTcpRx) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Gauge(
		"dummy.tcp.rx",
		otelmetricsdk.WithDescription("TCP received bytes"),
		otelmetricsdk.WithUnit("bytes"),
	)
	return err
}

// Record records a data point for the specified metric
// - pid : Process ID
func (m *MetricDummyTcpRx) Record(
	ctx context.Context,
	value int64,
	pid int,
	attributeOpts ...AttributeDummyTcpRxOption,
) {
	options := &AttributeDummyTcpRxOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Record(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeDummyTcpRxOptions struct {
}

type AttributeDummyTcpRxOption func(*AttributeDummyTcpRxOptions)

func (o *AttributeDummyTcpRxOptions) Apply(opts ...AttributeDummyTcpRxOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeDummyTcpRxOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}

// MetricDummyTcpTx TCP transmitted bytes
type MetricDummyTcpTx struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricDummyTcpTx) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"dummy.tcp.tx",
		otelmetricsdk.WithDescription("TCP transmitted bytes"),
		otelmetricsdk.WithUnit("bytes"),
	)
	return err
}

// Record records a data point for the specified metric
// - pid : Process ID
// - pidGid : Process Group ID
// - cpuId : cpu id in the range [0, numCPU]
func (m *MetricDummyTcpTx) Record(
	ctx context.Context,
	value int64,
	pid int,
	pidGid int,
	cpuId int,
	attributeOpts ...AttributeDummyTcpTxOption,
) {
	options := &AttributeDummyTcpTxOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
		otelattribute.Int("pid.gid", pidGid),
		otelattribute.Int("cpu.id", cpuId),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeDummyTcpTxOptions struct {
}

type AttributeDummyTcpTxOption func(*AttributeDummyTcpTxOptions)

func (o *AttributeDummyTcpTxOptions) Apply(opts ...AttributeDummyTcpTxOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeDummyTcpTxOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}
