// Package metrics is auto-generated by metricsgen. DO NOT EDIT.
package metrics

import (
	"context"
	otelattribute "go.opentelemetry.io/otel/attribute"
	otelmetricsdk "go.opentelemetry.io/otel/metric"
)

type Metrics struct {
	*MetricBpfTcpConnlat
	*MetricBpfTcpRx
	*MetricBpfTcpTx
}

// NewMetrics initializes the set of following metrics
// - BpfTcpConnlat  : TCP connection latency ms
// - BpfTcpRx  : TCP received bytes
// - BpfTcpTx  : TCP transmitted bytes
func NewMetrics(meter otelmetricsdk.Meter) (Metrics, error) {
	m := Metrics{
		MetricBpfTcpConnlat: &MetricBpfTcpConnlat{},
		MetricBpfTcpRx:      &MetricBpfTcpRx{},
		MetricBpfTcpTx:      &MetricBpfTcpTx{},
	}
	if err := m.MetricBpfTcpConnlat.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricBpfTcpRx.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricBpfTcpTx.init(meter); err != nil {
		return m, err
	}
	return m, nil
}

// MetricBpfTcpConnlat TCP connection latency ms
type MetricBpfTcpConnlat struct {
	data otelmetricsdk.Float64Histogram
}

func (m *MetricBpfTcpConnlat) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Float64Histogram(
		"bpf.tcp.connlat",
		otelmetricsdk.WithDescription("TCP connection latency ms"),
		otelmetricsdk.WithUnit("ms"),
	)
	return err
}

// Record records a data point for the specified metric
// - pid : Process ID
// - pidGid : Process Group ID
func (m *MetricBpfTcpConnlat) Record(
	ctx context.Context,
	value float64,
	pid int,
	pidGid int,
	attributeOpts ...AttributeBpfTcpConnlatOption,
) {
	options := &AttributeBpfTcpConnlatOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
		otelattribute.Int("pid.gid", pidGid),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Record(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeBpfTcpConnlatOptions struct {
}

type AttributeBpfTcpConnlatOption func(*AttributeBpfTcpConnlatOptions)

func (o *AttributeBpfTcpConnlatOptions) Apply(opts ...AttributeBpfTcpConnlatOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeBpfTcpConnlatOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}

// MetricBpfTcpRx TCP received bytes
type MetricBpfTcpRx struct {
	data otelmetricsdk.Int64Gauge
}

func (m *MetricBpfTcpRx) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Gauge(
		"bpf.tcp.rx",
		otelmetricsdk.WithDescription("TCP received bytes"),
		otelmetricsdk.WithUnit("bytes"),
	)
	return err
}

// Record records a data point for the specified metric
// - pid : Process ID
func (m *MetricBpfTcpRx) Record(
	ctx context.Context,
	value int64,
	pid int,
	attributeOpts ...AttributeBpfTcpRxOption,
) {
	options := &AttributeBpfTcpRxOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Record(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeBpfTcpRxOptions struct {
}

type AttributeBpfTcpRxOption func(*AttributeBpfTcpRxOptions)

func (o *AttributeBpfTcpRxOptions) Apply(opts ...AttributeBpfTcpRxOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeBpfTcpRxOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}

// MetricBpfTcpTx TCP transmitted bytes
type MetricBpfTcpTx struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricBpfTcpTx) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"bpf.tcp.tx",
		otelmetricsdk.WithDescription("TCP transmitted bytes"),
		otelmetricsdk.WithUnit("bytes"),
	)
	return err
}

// Record records a data point for the specified metric
// - pid : Process ID
// - pidGid : Process Group ID
func (m *MetricBpfTcpTx) Record(
	ctx context.Context,
	value int64,
	pid int,
	pidGid int,
	attributeOpts ...AttributeBpfTcpTxOption,
) {
	options := &AttributeBpfTcpTxOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.Int("pid", pid),
		otelattribute.Int("pid.gid", pidGid),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeBpfTcpTxOptions struct {
	cpuId *int
}

type AttributeBpfTcpTxOption func(*AttributeBpfTcpTxOptions)

func (o *AttributeBpfTcpTxOptions) Apply(opts ...AttributeBpfTcpTxOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeBpfTcpTxOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	if o.cpuId != nil {
		ret = append(ret, otelattribute.Int("cpu.id", *o.cpuId))
	}
	return ret
}

// WithBpfTcpTxCpuId sets the optional cpu.id attribute
// corresponding to cpu id in the range [0, numCPU]
func WithBpfTcpTxCpuId(cpuId int) AttributeBpfTcpTxOption {
	return func(o *AttributeBpfTcpTxOptions) {
		val := &cpuId
		o.cpuId = val
	}
}
