// Package benchmark is auto-generated by metricsgen. DO NOT EDIT.
package benchmark

import (
	"context"
	prommodel "github.com/prometheus/common/model"
	otelattribute "go.opentelemetry.io/otel/attribute"
	otelmetricsdk "go.opentelemetry.io/otel/metric"
)

// FIXME:hack for conformance tests, consistent metric exposing with prometheus driver
func init() {
	prommodel.NameValidationScheme = prommodel.LegacyValidation
}

type Metrics struct {
	*MetricEightLabelCounter
	*MetricFourLabelCounter
	*MetricNoLabelCounter
	*MetricOneLabelCounter
	*MetricSplitLabelCounter
}

// NewMetrics initializes the set of following metrics
// - EightLabelCounter  : counter with 8 labels
// - FourLabelCounter  : counter with 4 labels
// - NoLabelCounter  : counter with no labels
// - OneLabelCounter  : counter with 1 label
// - SplitLabelCounter  : counter with 4 labels and 4 optional labels
func NewMetrics(meter otelmetricsdk.Meter) (Metrics, error) {
	m := Metrics{
		MetricEightLabelCounter: &MetricEightLabelCounter{},
		MetricFourLabelCounter:  &MetricFourLabelCounter{},
		MetricNoLabelCounter:    &MetricNoLabelCounter{},
		MetricOneLabelCounter:   &MetricOneLabelCounter{},
		MetricSplitLabelCounter: &MetricSplitLabelCounter{},
	}
	if err := m.MetricEightLabelCounter.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricFourLabelCounter.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricNoLabelCounter.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricOneLabelCounter.init(meter); err != nil {
		return m, err
	}
	if err := m.MetricSplitLabelCounter.init(meter); err != nil {
		return m, err
	}
	return m, nil
}

// MetricEightLabelCounter counter with 8 labels
type MetricEightLabelCounter struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricEightLabelCounter) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"eight.label.counter",
		otelmetricsdk.WithDescription("counter with 8 labels"),
	)
	return err
}

// Record records a data point for the specified metric
//
// • stringLabel : A string label
// • stringLabel2 : A string label
// • stringLabel3 : A string label
// • stringLabel4 : A string label
// • stringLabel5 : A string label
// • stringLabel6 : A string label
// • stringLabel7 : A string label
// • stringLabel8 : A string label
func (m *MetricEightLabelCounter) Record(
	ctx context.Context,
	value int64,
	stringLabel string,
	stringLabel2 string,
	stringLabel3 string,
	stringLabel4 string,
	stringLabel5 string,
	stringLabel6 string,
	stringLabel7 string,
	stringLabel8 string,
	attributeOpts ...AttributeEightLabelCounterOption,
) {
	options := &AttributeEightLabelCounterOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.String("stringLabel", stringLabel),
		otelattribute.String("stringLabel2", stringLabel2),
		otelattribute.String("stringLabel3", stringLabel3),
		otelattribute.String("stringLabel4", stringLabel4),
		otelattribute.String("stringLabel5", stringLabel5),
		otelattribute.String("stringLabel6", stringLabel6),
		otelattribute.String("stringLabel7", stringLabel7),
		otelattribute.String("stringLabel8", stringLabel8),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeEightLabelCounterOptions struct {
}

type AttributeEightLabelCounterOption func(*AttributeEightLabelCounterOptions)

func (o *AttributeEightLabelCounterOptions) Apply(opts ...AttributeEightLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeEightLabelCounterOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}

// MetricFourLabelCounter counter with 4 labels
type MetricFourLabelCounter struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricFourLabelCounter) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"four.label.counter",
		otelmetricsdk.WithDescription("counter with 4 labels"),
	)
	return err
}

// Record records a data point for the specified metric
//
// • stringLabel : A string label
// • stringLabel2 : A string label
// • stringLabel3 : A string label
// • stringLabel4 : A string label
func (m *MetricFourLabelCounter) Record(
	ctx context.Context,
	value int64,
	stringLabel string,
	stringLabel2 string,
	stringLabel3 string,
	stringLabel4 string,
	attributeOpts ...AttributeFourLabelCounterOption,
) {
	options := &AttributeFourLabelCounterOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.String("stringLabel", stringLabel),
		otelattribute.String("stringLabel2", stringLabel2),
		otelattribute.String("stringLabel3", stringLabel3),
		otelattribute.String("stringLabel4", stringLabel4),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeFourLabelCounterOptions struct {
}

type AttributeFourLabelCounterOption func(*AttributeFourLabelCounterOptions)

func (o *AttributeFourLabelCounterOptions) Apply(opts ...AttributeFourLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeFourLabelCounterOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}

// MetricNoLabelCounter counter with no labels
type MetricNoLabelCounter struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricNoLabelCounter) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"no.label.counter",
		otelmetricsdk.WithDescription("counter with no labels"),
	)
	return err
}

// Record records a data point for the specified metric

func (m *MetricNoLabelCounter) Record(
	ctx context.Context,
	value int64,
	attributeOpts ...AttributeNoLabelCounterOption,
) {
	options := &AttributeNoLabelCounterOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeNoLabelCounterOptions struct {
}

type AttributeNoLabelCounterOption func(*AttributeNoLabelCounterOptions)

func (o *AttributeNoLabelCounterOptions) Apply(opts ...AttributeNoLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeNoLabelCounterOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}

// MetricOneLabelCounter counter with 1 label
type MetricOneLabelCounter struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricOneLabelCounter) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"one.label.counter",
		otelmetricsdk.WithDescription("counter with 1 label"),
	)
	return err
}

// Record records a data point for the specified metric
//
// • stringLabel : A string label
func (m *MetricOneLabelCounter) Record(
	ctx context.Context,
	value int64,
	stringLabel string,
	attributeOpts ...AttributeOneLabelCounterOption,
) {
	options := &AttributeOneLabelCounterOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.String("stringLabel", stringLabel),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeOneLabelCounterOptions struct {
}

type AttributeOneLabelCounterOption func(*AttributeOneLabelCounterOptions)

func (o *AttributeOneLabelCounterOptions) Apply(opts ...AttributeOneLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeOneLabelCounterOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	return ret
}

// MetricSplitLabelCounter counter with 4 labels and 4 optional labels
type MetricSplitLabelCounter struct {
	data otelmetricsdk.Int64Counter
}

func (m *MetricSplitLabelCounter) init(meter otelmetricsdk.Meter) error {
	var err error
	m.data, err = meter.Int64Counter(
		"split.label.counter",
		otelmetricsdk.WithDescription("counter with 4 labels and 4 optional labels"),
	)
	return err
}

// Record records a data point for the specified metric
//
// • stringLabel : A string label
// • stringLabel2 : A string label
// • stringLabel3 : A string label
// • stringLabel4 : A string label
func (m *MetricSplitLabelCounter) Record(
	ctx context.Context,
	value int64,
	stringLabel string,
	stringLabel2 string,
	stringLabel3 string,
	stringLabel4 string,
	attributeOpts ...AttributeSplitLabelCounterOption,
) {
	options := &AttributeSplitLabelCounterOptions{}
	options.Apply(attributeOpts...)
	optionalAttr := options.Attributes()
	requiredAttrs := []otelattribute.KeyValue{
		otelattribute.String("stringLabel", stringLabel),
		otelattribute.String("stringLabel2", stringLabel2),
		otelattribute.String("stringLabel3", stringLabel3),
		otelattribute.String("stringLabel4", stringLabel4),
	}

	attrs := otelattribute.NewSet(
		append(requiredAttrs, optionalAttr...)...,
	)
	m.data.Add(ctx, value, otelmetricsdk.WithAttributeSet(attrs))
}

type AttributeSplitLabelCounterOptions struct {
	stringLabel5 *string
	stringLabel6 *string
	stringLabel7 *string
	stringLabel8 *string
}

type AttributeSplitLabelCounterOption func(*AttributeSplitLabelCounterOptions)

func (o *AttributeSplitLabelCounterOptions) Apply(opts ...AttributeSplitLabelCounterOption) {
	for _, opt := range opts {
		opt(o)
	}
}

func (o *AttributeSplitLabelCounterOptions) Attributes() []otelattribute.KeyValue {
	ret := []otelattribute.KeyValue{}
	if o.stringLabel5 != nil {
		ret = append(ret, otelattribute.String("stringLabel5", *o.stringLabel5))
	}
	if o.stringLabel6 != nil {
		ret = append(ret, otelattribute.String("stringLabel6", *o.stringLabel6))
	}
	if o.stringLabel7 != nil {
		ret = append(ret, otelattribute.String("stringLabel7", *o.stringLabel7))
	}
	if o.stringLabel8 != nil {
		ret = append(ret, otelattribute.String("stringLabel8", *o.stringLabel8))
	}
	return ret
}

// WithSplitLabelCounterStringLabel5 sets the optional stringLabel5 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel5(stringLabel5 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel5
		o.stringLabel5 = val
	}
}

// WithSplitLabelCounterStringLabel6 sets the optional stringLabel6 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel6(stringLabel6 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel6
		o.stringLabel6 = val
	}
}

// WithSplitLabelCounterStringLabel7 sets the optional stringLabel7 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel7(stringLabel7 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel7
		o.stringLabel7 = val
	}
}

// WithSplitLabelCounterStringLabel8 sets the optional stringLabel8 attribute
// corresponding to A string label
func WithSplitLabelCounterStringLabel8(stringLabel8 string) AttributeSplitLabelCounterOption {
	return func(o *AttributeSplitLabelCounterOptions) {
		val := &stringLabel8
		o.stringLabel8 = val
	}
}
